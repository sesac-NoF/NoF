# -*- coding: utf-8 -*-
"""NOF EDA 데이터_판례내용.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LQzyer2DJPufjUKtu2U8ShbhVVx2-Ugj
"""

import pandas as pd
import numpy as np
import requests
import xml.etree.ElementTree as ET

print('완료')

OC = 'ykdb0508'
target = 'prec'
url = 'http://www.law.go.kr/DRF/lawSearch.do?'
data = []

for i in range(1, 6):  # Adjust the range based on the number of pages
    params = {
        'OC': OC,
        'target': target,
        'type': 'XML',
        'display': 100,
        'search': 1,
        'page': i
    }

    response = requests.get(url, params=params)

    if response.status_code == 200:
        root = ET.fromstring(response.content)
        items = root.findall('.//prec')

        # xml구조확인 (optional)
        # print(ET.tostring(root, encoding='utf-8').decode('utf-8'))

        if len(items) != 0:
            for item in items:
                ORDER_NUM = item.find('.//판례일련번호').text if item.find('.//판례일련번호') is not None else ''
                CASE_NAME = item.find('.//사건명').text if item.find('.//사건명') is not None else ''
                CASE_NUM = item.find('.//사건번호').text if item.find('.//사건번호') is not None else ''
                CASE_DATE = item.find('.//선고일자').text if item.find('.//선고일자') is not None else ''
                SCOURT = item.find('.//법원명').text if item.find('.//법원명') is not None else ''
                CASE = item.find('.//사건종류명').text if item.find('.//사건종류명') is not None else ''
                LINK = item.find('.//판례상세링크').text if item.find('.//판례상세링크') is not None else ''

                data.append([ORDER_NUM, CASE_NAME, CASE_NUM, CASE_DATE, SCOURT, CASE, LINK])
    else:
        print(f'Error on page {i}: Status code {response.status_code}')

# Convert to DataFrame
df = pd.DataFrame(data=data, columns=['판례일련번호', '사건명', '사건번호', '선고일자', '법원명', '사건종류명', '판례상세링크'])

# 목록
df

import requests
import xml.etree.ElementTree as ET
import pandas as pd
import re

# 판례를 가져오기 위한 기본 설정
OC = 'ykdb0508'
target = 'prec'
url = 'http://www.law.go.kr/DRF/lawService.do?'
data2 = []

# Loop through the DataFrame 'df' (assuming it exists)
for i in range(10):  # df의 길이에 따라 반복
    params = {
        'OC': OC,
        'target': target,
        'type': 'XML',
        'ID': df['판례일련번호'].iloc[i]  # Use '판례일련번호' from the DataFrame
    }

    response = requests.get(url, params=params)

    if response.status_code == 200:
        detail_root = ET.fromstring(response.content)  # Parse the response content

        # 판례내용 추출
        CASE_CONTENT = detail_root.find('.//판례내용')
        if CASE_CONTENT is not None:
            content = CASE_CONTENT.text
            print(content)  # 판례내용 출력

            # 정규 표현식을 사용하여 "【 】" 사이의 텍스트 및 해당 값을 찾기
            pattern = re.compile(r'【(.*?)】\s*(.*?)<br/>')
            matches = pattern.findall(content)

            # 추출된 데이터를 저장할 딕셔너리
            data_dict = {}

            # 추출한 데이터로 딕셔너리 채우기
            for col, val in matches:
                col = col.strip()  # 열 이름에서 공백 제거
                val = val.strip()  # 값에서 공백 제거

                if col in data_dict:
                    data_dict[col].append(val)  # 기존 열 리스트에 값 추가
                else:
                    data_dict[col] = [val]  # 새로운 열에 대한 리스트 생성

            # 모든 열이 같은 길이를 갖도록 보장
            max_len = max(len(v) for v in data_dict.values())
            for key in data_dict:
                while len(data_dict[key]) < max_len:
                    data_dict[key].append('')  # 빈 문자열로 채워 길이 맞추기

            # 딕셔너리를 DataFrame으로 변환
            df_extracted = pd.DataFrame(data_dict)

            # 중복된 열 처리: 각 열에 대해 이름을 기준으로 중복 제거 및 처리
            df_extracted = df_extracted.loc[:, ~df_extracted.columns.duplicated()]

            # 결과를 data2 리스트에 추가
            data2.append(df_extracted)

        else:
            print(f'판례내용을 찾을 수 없습니다. (판례 ID: {df["판례일련번호"].iloc[i]})')  # 인덱스를 i로 변경
    else:
        print(f'판례 상세 가져오기 오류: 상태 코드 {response.status_code}')

# 모든 판례의 DataFrame을 하나로 결합
if data2:
    final_df = pd.concat(data2, ignore_index=True)
    print(final_df.head())  # 최종 결과 출력 (첫 몇 행)
else:
    print("추출된 데이터가 없습니다.")

def reorder_columns(df):
    cols = df.columns.tolist()
    if '주문' in cols and '이유' in cols:
        cols.remove('주문')
        cols.remove('이유')
        cols.extend(['주문', '이유'])
        df = df[cols]
    return df

final_df.info()

final_df.head()

